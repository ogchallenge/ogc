<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>OGC2025</title>
    <meta
        name="description"
        content="OGC2025 공식 안내 링크 모음 - 문제 설명, 제출 안내, 예선/본선/결선 정보"
        data-desc-ko="OGC2025 공식 안내 링크 모음 - 문제 설명, 제출 안내, 예선/본선/결선 정보"
        data-desc-en="OGC2025 official hub for problem details, submissions, and stage updates"
    />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
        href="https://fonts.googleapis.com/css2?family=DM+Serif+Display&family=Geist:wght@300;400;500;600;700&family=Geist+Mono:wght@300;400;500;600;700&family=Noto+Sans+KR:wght@400;500;600;700&display=swap"
        rel="stylesheet"
    />
    <link rel="icon" type="image/svg+xml" href="../favicon.svg" />
    <link rel="stylesheet" href="../styles.ec248aaf09.css" />
    <!-- Year-specific overrides (if needed) -->
    <!-- <link rel="stylesheet" href="styles.488b17f19a.css" />
    <!-- Highlight.js for syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
</head>
<body>
    <!-- Detect iframe mode -->
    <script>
        const inIframe = window.parent !== window;
        if (inIframe) {
            document.documentElement.setAttribute('data-mode', 'iframe');
        }
    </script>
    <div class="layout">
        <aside class="sidebar">
            <a href="#home" class="sidebar__logo">OGC2025</a>
            <nav class="sidebar__sections" id="sidebarSections"></nav>
        </aside>

        <main class="main-content">
            <div id="app">
                <!-- Home page -->
                <div id="home" class="page">
                    <header class="hero">
                        <div class="hero__badge" data-lang="en">Optimization Grand Challenge 2025</div>
                        <div class="hero__badge" data-lang="ko">2025 최적화 그랜드 챌린지</div>
                        <h1 class="hero__title">OGC2025</h1>
                        <p class="hero__subtitle" data-lang="ko">
                            문제 설명, 알고리즘 제출, 예선/본선/결선 안내 및 결과를 조회할 수 있습니다.
                        </p>
                        <p class="hero__subtitle hero__subtitle--en" data-lang="en">
                            An archive for problem details, submission instructions, and stage updates.
                        </p>
                    </header>

                    <section id="sections" class="content"></section>

                    <footer class="footer">
                        <p data-lang="ko">OGC2025 공식 안내 링크 모음</p>
                        <p class="footer__en" data-lang="en">OGC2025 official link collection.</p>
                    </footer>
                </div>

                <!-- Content pages -->
                <div id="content-pages"></div>
            </div>
        </main>
    </div>

    <!-- Markdown renderer library -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- Highlight.js for syntax highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
    <!-- KaTeX for math rendering -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <script>
        // marked.js 렌더러 커스터마이즈 (이미지 경로 수정)
        const renderer = new marked.Renderer();
        
        // 원본 렌더러
        const originalImage = renderer.image.bind(renderer);
        const originalLink = renderer.link.bind(renderer);
        
        // 커스텀 이미지 렌더러
        renderer.image = (token) => {
            let href = token.href;
            let alt = token.text || '';
            let caption = alt;
            let width = '';
            
            // alt text에서 크기 정보 파싱 (예: "설명|600" 또는 "설명|80%")
            if (alt.includes('|')) {
                const parts = alt.split('|');
                caption = parts[0].trim();
                alt = caption;
                const sizeSpec = parts[1].trim();
                
                // 숫자만 있으면 px 단위로, %나 px가 포함되어 있으면 그대로 사용
                if (/^\d+$/.test(sizeSpec)) {
                    width = sizeSpec + 'px';
                } else if (/^\d+(%|px|em|rem)$/.test(sizeSpec)) {
                    width = sizeSpec;
                }
            }
            
            // 절대 경로나 외부 URL이 아닌 경우에만 처리
            if (!href.startsWith('http://') && !href.startsWith('https://') && !href.startsWith('/')) {
                // URL-encoded 경로 처리
                if (href.includes('%')) {
                    href = decodeURIComponent(href);
                }
                
                // 파일명만 추출하여 assets/ 경로로 변환 (상대 경로)
                const filename = href.split('/').pop();
                href = `assets/${filename}`;
            }
            
            // figure/figcaption으로 래핑하여 HTML 생성
            const title = token.title ? ` title="${token.title}"` : '';
            const widthStyle = width ? ` style="width: ${width}; height: auto;"` : '';
            const imgTag = `<img src="${href}" alt="${alt}"${widthStyle}${title}>`;
            const captionTag = caption ? `<figcaption>${caption}</figcaption>` : '';
            
            return `<figure>${imgTag}${captionTag}</figure>`;
        };
        
        // 커스텀 링크 렌더러 (마크다운의 상대 경로 그대로 사용)
        renderer.link = (token) => {
            let href = token.href;

            // 절대 경로나 외부 URL이 아닌 경우에만 처리
            if (!href.startsWith('http://') && !href.startsWith('https://') && !href.startsWith('/')) {
                // URL-encoded 경로 처리
                if (href.includes('%')) {
                    href = decodeURIComponent(href);
                }
            }

            token.href = href;
            return originalLink(token);
        };
        
        // marked 옵션 설정
        let language = 'en';
        marked.setOptions({
            breaks: true,
            gfm: true,
            highlight: function(code, lang) {
                if (lang && hljs.getLanguage(lang)) {
                    try {
                        return hljs.highlight(code, { language: lang }).value;
                    } catch (err) {}
                }
                return hljs.highlightAuto(code).value;
            }
        });
        
        // Sidebar/page configuration
        let pages = {};
        let sidebarConfig = null;

        async function loadSidebarConfig() {
            const response = await fetch('markdown/contents.4a716d9a87.json');
            if (!response.ok) {
                throw new Error(`Failed to load sidebar config: ${response.status}`);
            }
            return response.json();
        }

        function buildPagesMap(config) {
            pages = {};
            // 메인 페이지 추가
            pages['main'] = {
                title: {
                    en: 'Optimization Grand Challenge 2025',
                    ko: '최적화 그랜드 챌린지 2025'
                },
                file: 'main.67b2e67efb.md'
            };
            // sidebar config의 페이지들 추가
            (config.pages || []).forEach((page) => {
                if (!page.id) return;
                pages[page.id] = {
                    title: page.title || {},
                    file: page.file || '',
                    sidebarBgColor: page.sidebar_bgcolor || ''
                };
            });
        }

        function renderSidebar(config) {
            const nav = document.getElementById('sidebarSections');
            if (!nav) return;
            nav.innerHTML = '';
            (config.sections || []).forEach((section) => {
                const wrapper = document.createElement('div');
                wrapper.className = 'sidebar__category';

                const title = document.createElement('h3');
                title.className = 'sidebar__category-title';
                title.textContent = language === 'en' ? (section.title?.en || '') : (section.title?.ko || '');
                wrapper.appendChild(title);

                const list = document.createElement('ul');
                (section.items || []).forEach((pageId) => {
                    const page = pages[pageId];
                    if (!page) return;
                    const item = document.createElement('li');

                    const link = document.createElement('a');
                    link.href = `#${pageId}`;
                    link.textContent = language === 'en' ? (page.title?.en || pageId) : (page.title?.ko || pageId);
                    if (page.sidebarBgColor) {
                        link.style.setProperty('--sidebar-item-bg', page.sidebarBgColor);
                    }
                    item.appendChild(link);

                    list.appendChild(item);
                });

                wrapper.appendChild(list);
                nav.appendChild(wrapper);
            });
        }

        function renderHomeSections(config) {
            const container = document.getElementById('sections');
            if (!container) return;
            container.innerHTML = '';
            (config.sections || []).forEach((section) => {
                const card = document.createElement('section');
                card.className = 'card';

                const header = document.createElement('div');
                header.className = 'card__header';

                const title = document.createElement('h2');
                title.className = 'card__title';
                title.textContent = language === 'en' ? (section.title?.en || '') : (section.title?.ko || '');
                header.appendChild(title);

                const links = document.createElement('div');
                links.className = 'card__links';
                (section.items || []).forEach((pageId) => {
                    const page = pages[pageId];
                    if (!page) return;

                    const link = document.createElement('a');
                    link.href = `#${pageId}`;
                    link.textContent = language === 'en' ? (page.title?.en || pageId) : (page.title?.ko || pageId);
                    links.appendChild(link);
                });

                card.appendChild(header);
                card.appendChild(links);
                container.appendChild(card);
            });
        }

        // 마크다운 캐시
        const markdownCache = {};
        const DEFAULT_LANG = 'en';
        const SUPPORTED_LANGS = ['ko', 'en'];

        function getPreferredLang() {
            const saved = localStorage.getItem('ogc_lang');
            if (saved && SUPPORTED_LANGS.includes(saved)) return saved;
            const browserLang = (navigator.language || '').toLowerCase();
            return browserLang.startsWith('ko') ? 'ko' : DEFAULT_LANG;
        }

        function clearMarkdownCache() {
            Object.keys(markdownCache).forEach((key) => delete markdownCache[key]);
        }

        function setLang(lang) {
            if (!SUPPORTED_LANGS.includes(lang)) return;
            language = lang;  // 전역 변수 업데이트
            localStorage.setItem('ogc_lang', lang);
            document.documentElement.setAttribute('lang', lang);
            document.querySelectorAll('.lang-toggle').forEach((button) => {
                button.classList.toggle('is-active', button.dataset.lang === lang);
            });
            document.querySelectorAll('[data-lang]').forEach((node) => {
                if (node.classList.contains('lang-toggle')) return;
                node.classList.toggle('lang-hidden', node.dataset.lang !== lang);
            });
            const metaDesc = document.querySelector('meta[name="description"]');
            if (metaDesc) {
                const nextDesc = metaDesc.getAttribute(`data-desc-${lang}`);
                if (nextDesc) metaDesc.setAttribute('content', nextDesc);
            }
            clearMarkdownCache();
            // 언어 변경 후 sidebar와 홈 섹션 다시 렌더링
            if (sidebarConfig) {
                renderSidebar(sidebarConfig);
                renderHomeSections(sidebarConfig);
            }
        }

        function updateActiveNav(hash) {
            const current = hash || 'home';
            document.querySelectorAll('.sidebar__category a').forEach((link) => {
                const target = link.getAttribute('href').slice(1) || 'home';
                link.classList.toggle('active', target === current);
            });
        }

        // 마크다운 파일 로드 및 렌더링
        async function loadPage(pageId) {
            if (!pages[pageId]) {
                console.error(`Unknown page: ${pageId}`);
                return;
            }

            const page = pages[pageId];
            const lang = getPreferredLang();
            const pageTitle = page.title?.[lang] || page.title?.en || pageId;
            const cacheKey = `${lang}:${pageId}`;
            let markdown = markdownCache[cacheKey];

            if (!markdown) {
                try {
                    const pageFile = `markdown/${lang}/${page.file}`;
                    const response = await fetch(pageFile);
                    if (!response.ok) throw new Error(`Failed to load ${pageFile}`);
                    markdown = await response.text();
                    markdownCache[cacheKey] = markdown;
                } catch (error) {
                    console.error(`Error loading ${pageId} (${lang}):`, error);
                    return;
                }
            }

            // Remove the first H1 to avoid duplicating the page header.
            let cleanedMarkdown = markdown;
            const firstHeadingMatch = cleanedMarkdown.match(/^\s*#\s+.+(\r?\n|$)/);
            if (firstHeadingMatch) {
                cleanedMarkdown = cleanedMarkdown.replace(firstHeadingMatch[0], '');
            }

            // 수식 블록 보호 (marked.js 파싱 전에 placeholder로 치환)
            const mathBlocks = [];
            const mathInline = [];
            
            // 블록 수식 ($$...$$) 보호
            cleanedMarkdown = cleanedMarkdown.replace(/\$\$([\s\S]+?)\$\$/g, (match, formula) => {
                const index = mathBlocks.length;
                mathBlocks.push(formula.trim());
                return `\n\n<div class="math-display" data-math-index="${index}"></div>\n\n`;
            });
            
            // 인라인 수식 ($...$) 보호
            cleanedMarkdown = cleanedMarkdown.replace(/\$([^\$\n]+?)\$/g, (match, formula) => {
                const index = mathInline.length;
                mathInline.push(formula.trim());
                return `<span class="math-inline" data-math-index="${index}"></span>`;
            });

            // HTML 렌더링 (커스텀 renderer 사용)
            let html = marked.parse(cleanedMarkdown, { renderer });
            
            // 수식 복원 (렌더링을 위해 텍스트로 복원)
            html = html.replace(/<div class="math-display" data-math-index="(\d+)"><\/div>/g, (match, index) => {
                return `<div class="math-display">\\[${mathBlocks[index]}\\]</div>`;
            });
            
            html = html.replace(/<span class="math-inline" data-math-index="(\d+)"><\/span>/g, (match, index) => {
                return `<span class="math-inline">\\(${mathInline[index]}\\)</span>`;
            });
            
            // 페이지 HTML 생성
            const pageHTML = `
                <div id="${pageId}" class="page">
                    <main class="main-content">
                        <header class="page-header">
                            <h1>${pageTitle}</h1>
                        </header>
                        <article class="content">
                            ${html}
                        </article>
                    </main>
                </div>
            `;

            // 페이지 추가 또는 업데이트
            let container = document.getElementById('content-pages');
            container.innerHTML = '';
            container.insertAdjacentHTML('beforeend', pageHTML);
            
            // Syntax highlighting 적용
            container.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightElement(block);
            });
            
            // Math rendering with KaTeX (약간 지연시켜 라이브러리 로드 보장)
            setTimeout(() => {
                if (typeof renderMathInElement !== 'undefined') {
                    renderMathInElement(container, {
                        delimiters: [
                            {left: '$$', right: '$$', display: true},
                            {left: '$', right: '$', display: false},
                            {left: '\\[', right: '\\]', display: true},
                            {left: '\\(', right: '\\)', display: false}
                        ],
                        throwOnError: false
                    });
                } else {
                    console.warn('KaTeX renderMathInElement not loaded yet');
                }
            }, 100);
            
            // 홈 페이지 숨기기 (home 섹션이 없는 레이아웃도 안전 처리)
            const homeSection = document.getElementById('home');
            if (homeSection) {
                homeSection.style.display = 'none';
            }

            document.title = `OGC2025 - ${pageTitle}`;
            
            // 스크롤 위로
            window.scrollTo(0, 0);
        }

function navigateToHash(hash) {
            updateActiveNav(hash);
            if (!hash || hash === 'home') {
                loadPage('main');
            } else {
                loadPage(hash);
            }
        }

        function syncLangFromStorage() {
            const preferred = getPreferredLang();
            if (preferred === language) return;
            setLang(preferred);
            navigateToHash(window.location.hash.slice(1));
        }

        // 해시 변경 감지
        window.addEventListener('hashchange', () => {
            navigateToHash(window.location.hash.slice(1));
        });

        window.addEventListener('storage', (event) => {
            if (event.key === 'ogc_lang') {
                syncLangFromStorage();
            }
        });

        document.addEventListener('click', (event) => {
            const link = event.target.closest('a[href^="#"]');
            if (!link) return;
            const targetHash = link.getAttribute('href').slice(1) || 'home';
            const currentHash = window.location.hash.slice(1) || 'home';
            if (currentHash === targetHash) {
                event.preventDefault();
                navigateToHash(targetHash);
                return;
            }
        });

        document.querySelectorAll('.lang-toggle').forEach((button) => {
            button.addEventListener('click', () => {
                const lang = button.dataset.lang;
                setLang(lang);
                navigateToHash(window.location.hash.slice(1));
            });
        });

        function initResponsiveSidebar() {
            const layout = document.querySelector('.layout');
            const sidebar = document.querySelector('.sidebar');
            if (!layout || !sidebar) return;

            const mobileQuery = window.matchMedia('(max-width: 980px)');

            const toggleButton = document.createElement('button');
            toggleButton.type = 'button';
            toggleButton.className = 'sidebar-toggle-btn';
            toggleButton.setAttribute('aria-label', 'Open sidebar');
            toggleButton.setAttribute('aria-expanded', 'false');
            toggleButton.innerHTML = '&#9776;';

            const backdrop = document.createElement('div');
            backdrop.className = 'sidebar-backdrop';

            layout.appendChild(backdrop);
            document.body.appendChild(toggleButton);

            const closeSidebar = () => {
                layout.classList.remove('sidebar-open');
                toggleButton.setAttribute('aria-expanded', 'false');
                document.body.style.overflow = '';
            };

            const openSidebar = () => {
                layout.classList.add('sidebar-open');
                toggleButton.setAttribute('aria-expanded', 'true');
                document.body.style.overflow = 'hidden';
            };

            toggleButton.addEventListener('click', () => {
                if (layout.classList.contains('sidebar-open')) {
                    closeSidebar();
                } else {
                    openSidebar();
                }
            });

            backdrop.addEventListener('click', closeSidebar);

            sidebar.addEventListener('click', (event) => {
                const link = event.target.closest('a[href^="#"]');
                if (!link || !mobileQuery.matches) return;
                closeSidebar();
            });

            document.addEventListener('keydown', (event) => {
                if (event.key === 'Escape') {
                    closeSidebar();
                }
            });

            mobileQuery.addEventListener('change', (event) => {
                if (!event.matches) {
                    closeSidebar();
                }
            });

            closeSidebar();
        }



        async function init() {
            try {
                sidebarConfig = await loadSidebarConfig();
                buildPagesMap(sidebarConfig);
                // 언어 먼저 설정한 후 sidebar 렌더링
                setLang(getPreferredLang());
                renderSidebar(sidebarConfig);
            } catch (error) {
                console.error('Failed to load sidebar config:', error);
            }
            initResponsiveSidebar();
            syncLangFromStorage();
            navigateToHash(window.location.hash.slice(1));
        }

        // 초기 로드
        init();
    </script>
</body>
</html>
