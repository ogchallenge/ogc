# Competition Instances


This document describes how Stage 3 instances were generated based on [prob_gen_stage3.ipynb](rawdata/prob_gen_stage3.ipynb), using the following three raw order datasets:

- [opt_challenge_data_order_density_high.csv](rawdata/opt_challenge_data_order_density_high.csv)
- [opt_challenge_data_order_density_medium.csv](rawdata/opt_challenge_data_order_density_medium.csv)
- [opt_challenge_data_order_density_low.csv](rawdata/opt_challenge_data_order_density_low.csv)

While Stage 1 and Stage 2 instances were generated from a single raw dataset, Stage 3 leveraged the three raw datasets above to create instances with varying densities and patterns. In particular, mixed distribution instances were created by generating partial instances from each raw dataset and spatially blending them.

For Stage 1/2 instance generation, please refer to notebooks [prob_gen_stage1.ipynb](rawdata/prob_gen_stage1.ipynb) and [prob_gen_stage2.ipynb](rawdata/prob_gen_stage2.ipynb).

---

## 1) Input Data and Preprocessing

The `gen_problem_instance(...)` function in the notebook reads the raw CSV and generates the following columns:

- `ord_time_sec`: Relative time in seconds from the earliest order time (`earliest_date`) in the dataset
- `cook_time_sec`: `cook_time(minutes)` converted to seconds
- `capacity_bike`: Original capacity value multiplied by 100 and converted to integer

The main purpose is to normalize the order time series to a common axis (seconds) and to convert instance JSON values into numeric formats ready for computation.

---

## 2) Time Window Sampling

Instances are created by first selecting random continuous time windows from the raw data, then choosing orders within them.

1. Select a random start point for a time window of length `sampling_time_span_seconds` (e.g., 2 hours, 3 hours, 8 hours)
2. Retry until the number of orders in the window is at least `K * 1.2`
3. Randomly sample `K` orders without replacement from the window satisfying the condition
4. Realign the sampled orders' time axis to start from 0

In other words, the structure is **random start time + minimum density guarantee + final K order extraction**.

---

## 3) Distance Matrix and Order (Deadline) Calculation

### Distance Matrix (`DIST`)

- Collect shop and delivery coordinates from all orders to form a total of `2K` nodes
- Calculate distances between all node pairs using haversine formula
- Convert earth-radius-based distances (km) to meters, multiply by scalar `1.4`, and convert to integer

### Order Information (`ORDERS`)

Each order is recorded in the following format:

`[ORD_ID, ORD_TIME, SHOP_LAT, SHOP_LON, DLV_LAT, DLV_LON, VOL, COOK_TIME, DLV_DEADLINE]`

Deadline is calculated based on the arrival time for the CAR vehicle type plus a buffer:

DLV_DEADLINE = ORD_TIME + COOK_TIME + CAR_SERVICE_TIME + BUFFER_TIME + (shop→delivery distance / CAR speed)

Additionally, with probability `INC_BUFFER_TIME_PROB`, an extra `INC_BUFFER_TIME` (minutes) is added to the deadline to introduce random variations in deadline difficulty across orders.

---

## 4) Rider Parameter Settings

Each instance includes three rider types:

- `BIKE`, `WALK`, `CAR`

For each type, the following values are specified:

- Speed (`speed`)
- Capacity (`capa`)
- Variable cost (`var_cost`)
- Fixed cost (`fixed_cost`)
- Service time (`service_time`)
- Available number (`available number`)

By default, the available number is set as `NUM_*_RATIO × K`. In the notebook, different ratios, fixed costs, and buffers were used across instances to adjust difficulty levels.

---

## 5) Generation Methods Using 3 Raw Datasets

The notebook uses the high/medium/low density data in two ways:

### A. Single-Source Instances

Generated by directly calling `gen_problem_instance(...)` on one raw CSV.

- Example: `STAGE3_1` (high), `STAGE3_2` (medium), `STAGE3_3` (low)

### B. Mixed Instances

Partial instances are created from all three raw CSVs and merged using `merge_problems(...)`.

1. Generate partial instances from each of high/medium/low with different `K` and seed values
2. In `merge_orders(...)`, apply spatial transformations (`translations` and `rotations`) to each partial order group's coordinates
3. Merge the three order groups by time and reassign `ORD_ID`
4. Recalculate the distance matrix for all merged orders; rider availability is set to the sum of partial instances

This process creates **spatially mixed multi-distribution instances** rather than single-density patterns.


![Example of Stage3 instance created by merging 3 raw datasets](instance_gen_example.png)

In the figure, each color represents an order group generated from high/medium/low raw data. The three groups are spatially mixed, creating scenarios where riders must handle diverse order patterns simultaneously.
