# 문제설명 및 순위 결정 방법

*Update history:*

- *2024/07/15 - 순위계산 시 목적함수 비교 기준관련 내용 추가*
- *2024/06/25 - 리더보드 업데이트 기준관련 설명 추가*
- *2024/06/21 - 문제 json 포멧 설명 추가*
- *2024/05/08 - 알고리즘 소스 코드 표절 검사 관련 내용 추가*

## 0. 용어 설명

- 배달원(rider)
    - 배달 음식을 매장에서 찾아 주문한 고객에게 배달하는 사람을 의미합니다.
- 픽업(pickup)
    - 매장에서 고객의 주문을 인계 받는 것을 말합니다.
- 배달(delivery)
    - 매장에서 인계 받은 고객의 주문을 고객이 요청한 위치에 전달하는 것을 뜻합니다.
- 준비시각(readytime)
    - 고객의 주문이 준비되는 시각 = 고객이 주문을 하는 시각 (OT) + 주문이 매장에서 준비 되는 시간 (RT)
- 배달한계시각(deadline) - DT
    - 고객에게 배달해야 하는 한계시각을 뜻합니다. 이 시각 이전에 배달원은 고객에게 도착하여 주문을 배달 완료해야 합니다.
- 묶음 배송(bundle delivery)
    - 여러 개의 주문을 묶어 한 명의 배달원이 한꺼번에 배달하는 것을 말합니다.

## 1. 문제 상황

### 1.1. 주문

음식 주문 많이 해 보셨죠? 음식을 배달앱(App)을 통해 주문하면 다음과 같은 주문 정보가 생성되게 됩니다.

하나의 주문을 하나의 배달원이 배달하는 것은 비용적으로 효율적이지 않습니다. 
배달 업체는 비슷한 시점에 발생하는 여러 주문들을 묶어 필요한 배달원의 수를 줄여 배달 비용을 
줄이고 싶어합니다. 

여러분에게는 특정 지역에서 발행한 주문 목록이 주어집니다.  

그러나 주문을 묶음 배송하기 위해서는 다양한 제약 사항들을 고려해야 합니다. 
먼저 주문을 수행할 배달원에 대해 고려해 봅시다!

# Constraints

### 1.2. 배달원

세 종류의 배달원이 있습니다. 

![도보(Walk) 배달원|100](delivery-courier.png) 
![오토바이(Bike) 배달원|100](delivery-bike.png)
![차량(Car) 배달원|100](delivery-car.png)




각각의 배달원은 종류에 따라 **배달용량(capacity)**, **이동속도(speed)**, **접근시간(service time)**, **비용(cost)** 이 다릅니다. 예를 들어, 

- 도보 배달원은 가장 느리지만 배달업체가 지불하는 비용은 가장 저렴합니다.
- 오토바이 배달원은 가장 빠르지만 비용이 많이 들고,
- 차량은 배달용량은 다른 배달원에 비해 크지만 주차하는데 더 많은 시간(즉, 접근시간)이 소요됩니다.

그리고 배달원에게 지불하는 비용은 다음과 같이 결정됩니다.

**배달 비용**

> **묶음 배달 비용 = 배달원 유형에 따른 고정비 + 배달원 유형에 따른 변동비(거리당 비용)**


 배달원의 종류에 따라 고정비와 변동비는 다르게 주어집니다. 

> **주의!** 배달원의 유형에 따른 고정비는 배달원이 몇 개를 묶어 배송하든 상관없이 한 번만 부과됩니다.


> **주의!** 변동비는 **거리** 에 비례합니다! 배달원 종류마다 이동속도가 다르므로 이동시간은 다를 수 있지만 같은 거리를 이동하면 같은 거리를 기준으로 변동비가 계산됩니다.


고객들 입장에서는 주문을 할 때 지불할 배달료가 미리 결정되고 배달한계시각 이전에 배달이 되기만 하면 어떤 종류의 배달원이 올지는 중요하지 않습니다. 하지만 배달 업체는 배달원의 종류에 따라 지불할 비용이 달라지게 됩니다.  
하지만, 그렇다고 해서 가장 비용이 싼 배달원만 이용하는 것은 어렵습니다. 이용 가능한 배달원의 수는 한계가 있기 때문입니다. 
그렇다면, 여러 개의 주문을 묶어 한꺼번에 배달하게 하여 필요한 배달원의 수를 줄이면 어떨까요? 당연히 비용이 줄어들 것 입니다! 그러나 묶음 배송을 수행하기 위해서는 고려해야 할 사항들이 있습니다.

### 1.3. 묶음 배송 제약

주문을 모아 묶음 배송을 하기 위해서는 다음의 제약을 만족해야 합니다.


💡 **제약 1.** *묶음 주문의 부피의 총합이 배달원의 용량(capacity)을 넘지 않아야 함: **용량 제약***


💡 **제약 2.** *모든 주문들은 배달한계시각(deadline) 이전에 배달되어야 함: **시간 제약***


💡 **제약 3.** *묶음 배송을 할 때 먼저 픽업을 모두 수행하고 배달을 수행해야 함: **방문 순서 제약***



위 조건을 만족해서 생성된 묶음 배달을 배달원들에게 할당합니다. 
따라서 이용 가능한 배달원에 대한 다음 조건을 추가적으로 만족해야 합니다.

💡 **제약 4.** *모든 주문은 빠짐 없이 배달원에 의해 배달되어야 함: **주문 만족 제약***

💡 **제약 5.** *한 배달원에게 할당되는 묶음 배송 수는 최대 1개임: **배달원 할당 제약***


## 2. 예제

다음과 같은 두 개의 주문이 주어졌을 때를 생각해 봅시다.

![주문 예제](example-orders-diagram.png)

예제의 두 개의 주문에는 두 개의 픽업(pickup) 매장과 두 개의 배달(delivery) 지점이 있습니다. 
픽업 장소와 배달 장소들 간의 거리는 다음과 같습니다.

![아크(arc)의 숫자는 이동 거리를 의미함](distance-network-diagram.png)


두 개의 주문을 묶기 위해서는 두 가지 제약을 만족해야 합니다. 

**제약 1. 용량 제약**

용량 제약의 경우 두 주문의 용량의 합이 90(=40+50) 이므로 도보 배달원은 배달이 불가능합니다. 
오토바이와 차량은 모두 용량 제약을 만족합니다! 
이번에는 시간 제약이 만족하는지 살펴봅시다. 

**제약 2. 시간 제약**

시간제약을 만족하기 위해서는 배달원은 

1. 픽업시에는 준비시각(readytime) 이후에 다음 장소로 출발하고
2. 배달시에는 배달한계시각(deadline)-접근시간(service time) 이전에 도착

해야  합니다. 오토바이를 이용해서 다음과 같은 순서로 배송을 하는 경우를 생각해 봅시다.

![아크의 숫자는 오토바이의 이동시간을 의미함](bike-time-network-diagram.png)


배송 순서대로 자세히 설명하면,

1. 주문 1의 픽업 장소: 15시각에 픽업을 완료하고 다음 장소로 출발합니다. 
이 때 15는 주문 1의 준비시각(readytime)이고 이 배달원은 충분히 이전에 도착하여 이미 접근을 모두 마쳤다고 가정합니다.


> 💡 **묶음 배송의 첫 번째 장소에서는 접근시간을 고려하지 않고 readytime 이후에 출발 가능!**



1. 주문 2의 픽업 장소: 오토바이의 속도가 2이기 때문에 주문 1의 픽업 장소에서 주문 2의 픽업 장소로 이동 하는데는 10의 시간이 소요됩니다. 즉, 25 시각에 도착해서 3의 접근시간이 필요하니 28 시각에 매장에 도착합니다. 그러나 주문 2의 readytime이 30(=주문 발생 시각 10 + 주문 준비 시간 20) 이므로 30 이후에 출발합니다. (2의 대기시간 발생)


> 💡 **readytime은 주문 발생시각 + 주문 준비 시간으로 계산!**


1. 주문 1의 배달 장소: 30 시각에 출발해서 주문 1의 배달 장소에 70에 도착하고 접근시간 3 이후인 73에 배달이 이루어집니다. 이는 주문 1의 deadline인 80 이하 이므로 주문 1 배달 성공입니다!
2. 주문 2의 배달 장소: 73에 출발해서 92에 도착하고 3의 접근시간을 더하면 95에 배달 가능하고 이는 주문 2의 배달 한계 시간 95 이하 이므로 주문 2 배달 성공입니다!

**제약 3. 방문순서 제약**

또한, 위 예제의 두 주문을 묶을 수 있는 유일한 방법은 오토바이 배달원이 위와 같은 방문 순서로 배송할 때만 가능함을 알 수 있습니다. 위 예제의 방문순서를 자세히 살펴 보면, 두 개 주문의 픽업 장소를 모두 방문한 후에 두 개의 배달을 수행합니다. 
즉, 주문 1의 픽업 장소에서 바로 주문 1 또는 주문 2의 배달 장소를 방문할 수 없습니다. 

> **주의! 픽업을 모두 완료한 후, 배달 장소를 방문 가능 합니다.**
> 

**제약 4. 주문 만족 제약**

주문 1과 주문 2를 모두 배달 완료했으므로 주문 만족 제약을 총족시킨 것을 알 수 있습니다. 

**즉, 하나의 묶음 배송을 생성하기 위해서는 다음을 결정해야 합니다.**

1. **배달원 종류(도보, 오토바이, 차량 중 하나)**
2. **용량 제약을 만족하는 묶을 주문 집합**
3. **시간 제약을 준수하는 방문 순서**

### 또 다른 예제

이번에는 다른 예제를 살펴봅시다. 주문이 10개 주어졌습니다(주문번호 1~주문번호 10). 
제약사항들을 확인해보니 각각 두 개씩의 주문을 오토바이 또는 차량으로 묶음 배송이 가능하다고 가정합니다. 

- 주문 1 & 2: 오토바이 또는 차량 묶음 배송 가능
- 주문 3 & 4: 오토바이 또는 차량 묶음 배송 가능
- 주문 5 & 6: 오토바이 또는 차량 묶음 배송 가능
- 주문 7 & 8: 오토바이 또는 차량 묶음 배송 가능
- 주문 9 & 10: 오토바이 또는 차량 묶음 배송 가능

그리고 오토바이 배달원은 3명, 차량 배달원은 10명 이용 가능하다고 주어졌다고 가정합니다.

모든 묶음 배송의 방문 순서가 오토바이 또는 차량에 대해 동일하다면 묶음 배송마다 이동거리는 같습니다. 즉, 각 묶음 배송의 비용은 오토바이와 차량의 고정비와 변동비에 따라 결정 됩니다. 
예제를 단순하게 생각하기 위해 모든 묶음 배송의 경우에 오토바이가 더 저렴하다고 가정합시다. 
5개 묶음 배송을 모두 오토바이 배달원에게 할당하면 가장 적은 비용이 발생하겠군요! 

**제약 5. *배달원 할당 제약***
그러나 **제약 5** 을 만족해야 하기 때문에 다섯개 묶음 배송 중에 최대 3개까지 오토바이 배달원에게 할당해야 합니다. 나머지 2개의 묶음 배송은 차량 배달원에 할당되어야 합니다.
즉, 묶음 배송이 여러가지 배달원 유형이 가능하면 어떤 유형의 배달원에 할당할지는 배달원의 이용가능 숫자를 고려해야 합니다. 그리고, 배달원은 하나의 묶음 배달을 수행하고 또 다른 묶음 배달을 수행할 수 없습니다. 

## 3. 목적함수

묶음 배송마다 배달원 유형이 정해지고 방문 순서가 결정되면 거리를 통해 비용을 계산할 수 있습니다. 모든 묶음 배송의 비용을 다 더하면 총 비용이 되고 이를 주문 갯수로 나누면 평균 배달 비용이 됩니다.

> 목적함수 = 평균 배달 비용 = 총 배달 비용 / 총 주문 갯수


## 4. 문제 데이터 정의

하나의 문제에는 다음과 같은 데이터가 제공됩니다.

- `K` 개의 주문 목록
- 배달원 종류와 특성
- 거리 행렬(distance matrix)

문제는 json 형태로 제공되며 아래와 같은 항목들이 있습니다.

```json
{
 "name": "TEST_K50_1",
 "K": 50,
 "RIDERS": [["BIKE", 5.291005291005291, 100, 80, 2200, 120, 5],
            ["WALK", 1.3227513227513228, 70, 50, 2200, 120, 10],
            ["CAR", 4.2328042328042335, 200, 60, 2200, 150, 50]],
 "ORDERS": [[0, 7, 37.49493567, 127.03071274, 37.501853, 127.037541, 900, 40,
             1980],
            [1, 53, 37.49246391, 127.04021194, 37.491006, 127.023683, 1200, 42,
             2489],
            [2, 95, 37.5030462, 127.05048848, 37.503553, 127.053148, 600, 28,
             1525],
            [3, 142, 37.50457363, 127.04140593, 37.507767, 127.025053, 900, 19,
             2284],
            [4, 221, 37.48549201, 127.01352012, 37.48385, 127.015403, 1800, 40,
             2853],
            [5, 391, 37.50960069, 127.0335454, 37.494084, 127.028143, 900, 20,
             2634],
            [6, 597, 37.5001711, 127.0522837, 37.499698, 127.069605, 900, 47,
            ...
            
            
 "DIST": [[0, 1236, 2753, 2001, 2586, 2312, 2789, 1809, 3978, 2126, 1551, 2312,
           3807, 2483, 1067, 1453, 4188, 1479, 2364, 10027, 3689, 1859, 7330,
           3495, 3046, 460, 3150, 1552, 2548, 3351, 5412, 3020, 2534, 3122,
           2839, 1484, 1722, 3092, 3046, 2534, 2736, 2685, 522, 3483, 4065,
           3340, 3631, 2504, 1739, 2016, 1369, 1063, 3082, 2119, 2563, 344,
           4866, 1392, 3266, 1390, 1099, 2370, 3919, 537, 4834, 2318, 5043,
           2569, 1205, 9609, 2283, 2153, 5245, 5640, 3381, 1836, 2976, 1035,
           766, 2211, 3830, 3174, 4051, 3838, 4587, 1753, 1771, 2588, 2244,
           2176, 213, 3015, 2257, 2138, 3673, 3806, 1023, 3278, 4554, 1559],
          [1236, 0, 2082, 1893, 3475, 2795, 1916, 2916, 2933, 2903, 1802, 2795,
           4676, 2654, 1264, 1693, 3627, 2660, 3542, 8791, 2502, 1572, 8409,
           4673, 1999, 1577, 4307, 445, 2105, 4261, 5164, 4021, 2884, 2078,
           4008, 1651, 1716, 3607, 1999, 2884, 1900, 1795, 1174, 3641, 5288,
           2621, 2822, 3446, 2725, 2872, 1500, 2056, 2355, 3033, 3349, 1514,
           3805, 683, 2743, 1865, 1317, 3032, 4883, 1487, 4664, 2814, 4034,
           3662, 954, 8375, 1053, 2744, 6362, 6238, 2967, 2902, 4175, 225, 954,
           1961, 3661, 3880, 3910, 3844, 5370, 2860, 2826, 2991, 1009, 3203,
           1024, 2295, 1798, 2543, 4908, 4641, 2157, 3803, 5788, 2314],
           ...
  }
```

- `name`: 문제의 이름
- `K`: 문제의 주문 갯수
- `RIDERS`: 배달원 정보 e.g. `["BIKE", 5.291005291005291, 100, 80, 2200, 120, 5]`
    - 종류: `BIKE`, `WALK`, 또는 `CAR`  → `“BIKE”`
    - 속도: 거리(m)/시간(초) 단위 → `5.291005291005291`
    - 용량 → `100`
    - 변동비 (100m당)  → `80`
    - 고정비 → `2200`
    - 접근 시간(초) → `120`
    - 배달원 가용 수(availability) → `5`
    
    > **주의!** 차량 배달원은 항상 주문의 갯수와 같은 가용 수가 주어집니다. 즉, 모든 주문을 묶음 없이 차량으로 하나씩 배송하는것은 항상 가능합니다! 물론 비용면에서는 좋지 않겠지요!
    > 
- `ORDERS`: 주문 정보 e.g. `[0, 7, 37.49493567, 127.03071274, 37.501853, 127.037541, 900, 40, 1980]`
    - 주문 아이디 → `0`
    - 주문발생시각(초)  → `7`
    - 픽업 (pickup) 장소 위도 좌표  → `37.49493567`
    - 픽업 (pickup) 장소 경도 좌표 → `127.03071274`
    - 배달 (delivery) 장소 위도 좌표 → `37.501853`
    - 배달 (delivery) 장소 경도 좌표 → `127.037541`
    - 주문 준비 시간(초): *주문발생시각에 요리 준비 시각을 더하면 pickup의 readytime* → `900`
    - 주문의 부피 → `40`
    - 배달한계시각(deadline, 초) → `1980`
- `DIST`: 거리 행렬
    - `2K * 2K` 행렬
    - m단위(정수로 반올림)
    - 예) 주문 `i`의 픽업 장소와 주문 `j`의 픽업 장소 사이의 거리 = `DIST[i,j]`
    - 예) 주문 `i`의 픽업 장소와 주문 `j`의 배달 장소 사이의 거리 = `DIST[i,j+K]`
    - 예) 주문 `i`의 배달 장소와 주문 `j`의 배달 장소 사이의 거리 = `DIST[i+K,j+K]`
    
    > **주의!** 이동시간은 별도로 주어지지 않고 배달원 속도와 거리를 이용해서 구합니다.
    초 단위로 반올림한 정수값 사용하면 됩니다! 이 때 접근 시간(service time)을 이동시간에 더해서 고려할 수 있음
    
    Python 이동시간 변환 예) 
    `rider.T = np.round(*dist_mat*/rider.speed + rider.service_time)`
    > 

## 5. 알고리즘의 해 (Solution)

알고리즘은 주어진 문제 데이터에 대해 다음과 같은 해를 반환해야 합니다.

- 알고리즘은 주어진 문제에 대해 `[배달원 종류, 음식점 방문 순서, 고객 방문 순서]` 의 리스트를 반환
- 방문 순서는 주문  `[1,3,2]` 와 같이 주문 id의 순서로 정의됨
- 예) `["BIKE", [1,3,2], [2,3,1]]`
    - 의미: 주문 1,2,3을 묶어 오토바이 배달원에 할당하고 1,3,2 순서로 픽업 장소를 방문하고 2,3,1 순서로 배달 장소 방문
    - Bike: P1 → P3 → P2 → D2 → D3 → D1

목적함수 및 제약사항 만족 여부는 채점 시스템에서 수행합니다. 
즉, 참가팀이 제출한 해는 각각의 묶음 배송에 대해 **제약 1, 제약 2, 제약 3**를 만족해야 하고, 전체 묶음 배송은 **제약 4, 제약 5**를 만족해야 합니다.

## 6. 알고리즘의 제출 및 평가

참가팀은 단계(예선, 본선, 결선) 별로 주어지는 문제를 대상으로 알고리즘을 작성합니다(공개된 문제). 구현된 알고리즘 코드를 경연 시스템에 제출하면 숨겨진 문제를 대상으로 제출한 알고리즘을 실행해서 평가 합니다. 알고리즘 평가 서버 사양은 다음과 같습니다.

- AWS EC2 인스턴스(c5.2xlarge)
- 8 Core, 메모리 16 GB, Storage 32GB
- OS: Ubuntu 22.04 LTS

알고리즘은 실행시간제약(time limit)이 주어집니다. 예를 들어 예선은 문제 당 1분의 시간제한을 가지고 본선, 결선은 시작할 때 구체적인 시간제한이 주어질 예정입니다.


> 💡 **예선의 알고리즘 시간제한은 문제당 1분!**


참가팀의 PC사양이 평가 서버의 사양과 다르기 때문에 참가팀의 알고리즘은 알고리즘 수행 중에 경과된 시간을 확인하여 제한시간을 넘지 말아야 합니다. 

또한 참가팀이 제출한 알고리즘은 다음과 같은 제약을 같습니다.

- 알고리즘 수행중에 외부 인터넷 접근 불가능
- 최대 4개의 cpu core 사용 가능(~ CPU 사용률 400%)

위의 제약을 어기는 알고리즘은 실격처리 될 수 있습니다. 

> 💡 **알고리즘 외부 인터넷 사용 여부와 cpu core 수는 평가서버에서 알고리즘 실행 시 `firejail`과 `cpulimit` 를 통해 강제됨. 참가자의 알고리즘은 이 둘 프로그램과 충돌이 없어야 함**


참가팀은 하루에 1회 알고리즘을 제출할 수 있습니다. 하루의 기준은 한국 표준 시간으로 오전 0시 부터 오후 23시 59분까지 입니다. 즉, 제출 순간의 날짜 기준으로 같은 날짜에는 최대 한번만 제출 가능합니다.

> 💡 **알고리즘 제출은 하루에 최대 1회만 가능!**


제출된 알고리즘은 평가 서버에서 숨겨진 문제를 대상으로 알고리즘을 실행해서 그 결과는 정해진 시각(정확한 시간은 추후 공개)에 취합됩니다. 취합된 결과는 경연 홈페이지의 순위표(leaderboard)에 반영됩니다.

> 💡 **순위표는 하루 한번 정해진 시각에 업데이트!**

참가팀이 제출한 알고리즘들 중에 가장 나중에 제출한 알고리즘 기준으로 모든 평가가 이루어집니다. 

> 💡 **평가 시간 기준으로 가장 최근에 제출한 알고리즘이 모든 평가의 기준!**

즉, 단계의 종료일 직전에는 가장 좋았던 알고리즘을 꼭 다시 제출하세요! 그렇지 않으면 마지막에 제출했던 알고리즘 기준으로 순위가 결정됩니다.

숨겨진 평가 문제는 공개하는 문제들과 비슷한 특성을 가지는 문제들로 이루어집니다. 단계별로 평가 문제의 갯수는 다르게 주어집니다. 예를 들어 5개 팀이 알고리즘을 제출하였고 3개의 숨겨진 평가 문제가 있을 때 숨겨진 문제를 푼 결과가 다음과 같다고 가정합니다. 

- `TEAM00`
    - `prob1: obj=60, feasible`
    - `prob2: obj=121, feasible`
    - `prob3: obj=82, feasible`
- `TEAM01`
    - `prob1: obj=104, infeasible`
    - `prob2: obj=223, feasible`
    - `prob3: obj=95, feasible`
- `TEAM02`
    - `prob1: obj=141, feasible`
    - `prob2: obj=125, feasible`
    - `prob3: obj=102, feasible`
- `TEAM03`
    - `prob1: obj=80, feasible`
    - `prob2: obj=136, feasible`
    - `prob3: obj=129, feasible`
- `TEAM04`
    - `prob1: obj=183, feasible`
    - `prob2: obj=210, feasible`
    - `prob3: obj=54, feasible`

위의 결과는 평가 시스템이 제출한 알고리즘을 숨겨진 문제에 대해 푼 결과입니다. 문제에 따라 infeasible 여부도 같이 판단됩니다. 그러면 문제 $p$에 대해 다음의 값을 계산할 수 있습니다.

$$
nb_p = |\{\text{문제 $p$에 대해 더 좋은 목적함수를 찾은 팀}\}|
$$

즉, $nb_p$는 문제 $p$에 대해 좋은 해를 찾은 알고리즘일수록 작은 값을 가지게 됩니다. 또한 이 때 찾은 해가 infeasible이거나 알고리즘의 실행 시 crash가 발생한 경우에는 가장 안 좋은 목적함수로 취급합니다. 

계산한 $nb_p$값으로 각 문제의 점수(point)는 다음과 같이 계산됩니다.

$$
p_p = \begin{cases} \max \{0, R-nb_p\} &\text{ if solution is feasible}\\ -1 &\text{otherwise} \end{cases}
$$

> 💡 **알고리즘의 해가 infeasible이거나 시간제한 초과, 수행 불가(crash)등의 경우에는 해당 문제에 대해 손해(penalty) 점수(-1)를 얻습니다!**


이 때 $R$은 평가하는 팀의 갯수입니다. 모든 문제에 대해 포인트를 계산하고 포인트의 총합 기준으로 순위가 결정됩니다. 아래 표는 위 예제에 대한 순위표를 보여줍니다.

```

  team  nb_prob1  p_prob1  nb_prob3  p_prob3  nb_prob2  p_prob2  total_score  ranking
TEAM00         0        5         1        4         0        5           14        1
TEAM02         2        3         3        2         1        4            9        2
TEAM05         3        2         0        5         3        2            9        2
TEAM03         1        4         4        1         2        3            8        4
TEAM01         5       -1         2        3         4        1            3        5
```

### 리더보드 업데이트 관련

**리더보드는 매일 오후 1시(13:00)에 업데이트 됩니다. 리더보드의 결과는 당일 오전 0시(전날 밤 12시)까지 실행된 알고리즘을 대상으로 만들어 집니다.** 즉, 어떤 팀이 어제 밤 11시에 알고리즘을 제출하고 오늘 오전 9시에 알고리즘을 새로 제출했으면 오늘 13:00에 업데이트되는 리더보드는 어제 제출한 알고리즘을 기준으로 점수가 계산됩니다. 즉, 당일 오전 0시 이전에 실행된 알고리즘들중에 가장 최신 알고리즘이 평가 대상입니다.

### 목적함수 비교 시 계산 오차(numerical error) 관련 사항(updated on 2024-07-15)

목적함수를 비교할 때는 소수점 세째자리에서 반올림해서 비교합니다. 예를 들어 두개의 목적함수 값이 100.122999997, 100.123이라면 반올림하면 100.12, 100.12가 됩니다. 따라서 같은 목적함수로 인정됩니다. 이렇게 하는 이유는 알고리즘이 반환한 해(solution)의 목적함수 값을 계산할 때 발생할 수 있는 계산오차를 고려하기위해서 입니다. (*평가 서버는 2024-07-15 기준으로 이와같은 기준을 사용하도록 업데이트 됩니다. 따라서 2024-07-15이후의 리더보드 점수는 이전과 약간 다를 수 있습니다.)*

### 최종 발표 평가 반영 방법

결선에 진출한 참가팀을 대상으로 발표 평가가 이루어지며, 심사위원의 평가 점수를 합산하여 발표평가 점수가 산정됩니다. 최종 순위는 결선 리더보드 득점과 발표평가 점수를 일정 비율로 합산하여 결정됩니다.


> 💡 **최종 순위는 결선 리더보드 득점과 발표평가 점수를 일정비율로 합산하여 결정. 단계별 숨겨진 평가 문제의 수는 각 단계가 시작될 때 공개!**

### 알고리즘 소스 코드 표절 검사

참가팀이 제출한 알고리즘은 참가팀의 충분한 기여점들을 포함해야 합니다. 예를 들어, 원래 같은 팀 멤버들이 거의 비슷한 알고리즘을 여러개의 팀 이름으로 제출하는것은 허용되지 않습니다. [알고리즘 제출방법](#baseline-algorithm)에 자세히 나와있는 대로 알고리즘 제출시에는 알고리즘의 소스도 같이 제출합니다. 제출한 소스는 추후 참가팀들 간에 소스의 표절여부를 확인할 때 사용될 수 있습니다. 알고리즘의 고유성 여부는 명확하게 판단하기 어려운게 사실입니다. 본 대회는 참가팀들이 상식적인 수준에서 명예로운 방식으로 대회에 참가하는것을 가정합니다. 만약에 이 가정에 어긋나는 행동을 한 참가팀은 운영 위원회의 결정에 따라 참여가 제한될 수 있습니다.

All icons from Flaticon designed by Smashicons, iconixar, Freepik, Paul J., and kliwir art.