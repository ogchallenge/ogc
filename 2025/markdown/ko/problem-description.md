# 문제 설명 및 순위 결정 방법

*Update history:*

- *2025/07/01 - 춘계공동학술대회 문제 설명 자료 추가*
- *2025/05/12 - 문제 설명 podcast 추가*
- *2025/05/07 - initial page created*


# 0. 용어 설명

- 선적(loading)
    - 차량을 항구에서 선박에 싣는 것을 의미합니다.
- 하역(unloading)
    - 차량을 선박에서 항구로 내리는 것을 의미합니다.
- 상하역(loading and unloading)
    - 차량을 선박에 싣거나 내리는 것, 즉 선적 또는 하역하는 것을 말합니다.
- 적재(placement)
    - 차량을 선박 내의 특정 공간에 배치하는 것을 말합니다.
- 선박의 내부 구조(deck graph)
    - 노드(node)
        - 선박 내에 한 대의 차량을 배치할 수 있는 개별 공간은 노드로 표현됩니다.
    - 간선(edge)
        - 노드와 노드 사이를 연결하는 선으로, 두 노드가 간선으로 연결되어 있으면 차량이 이동 가능함을 나타냅니다.
    - 출입구(gate node)
        - 차량을 항구에서 상하역할 수 있는 통로로, 노드 0으로 표현되며 선박에 출입구는 하나입니다.
        - 출입구에는 차량 적재가 불가능합니다.
- 위치변경(relocation)
    - 차량을 선박 내에서 이동하여 특정 노드에서 다른 노드로 위치를 변경하는 것을 의미합니다.
- 임시 하역
    - 차량을 도착지 항구가 아닌 항구에서 잠시 하역하는 것을 의미합니다.
- 재적재
    - 차량을 임시 하역 후 다시 차량에 싣고 노드에 적재하는 것을 말합니다. 이때 기존과 다른 노드에 적재가 가능합니다.
- 재배치(rehandling)
    - 특정 차량의 위치를 변경하는 방법은 크게 두 가지가 있습니다.
        - 위치변경
        - 임시 하역 후 재적재
- 차량 수송 수요(demand)
    - 차량의 출발지-목적지와 차량의 수량으로 주어집니다.
- 경로(route)
    - 차량이 deck graph상에서 이동하는 순서를 나타내는 노드들의 목록으로 정의됩니다.
    - 선적, 하역, 적재, 재적재, 재배치 등은 모두 deck graph상의 경로로 표현됩니다.

# 1. 문제 상황

![출처: [https://www.news1.kr/economy/trend/5312046](https://www.news1.kr/economy/trend/5312046) ⓒ News1 윤일지 기자](roroship.png)


[https://youtu.be/Ug3SQBoDS1E?si=EIXZDQ7QhR1braZE](https://youtu.be/Ug3SQBoDS1E?si=EIXZDQ7QhR1braZE)

완성차를 미국, 유럽 등 주요 해외 시장에 수출하기 위한 운송 수단으로 주로 선박을 이용합니다. 선박은 여러 항구를 방문하며 차량의 상하역 과정을 반복하고, 이 과정에서 선박 내에 효율적인 차량 적재가 중요합니다. 

특히, 선박 내 깊숙한 위치에 적재된 차량을 내리기 위해서는 해당 차량이 이동하는 경로에 있는 다른 차량을 선박 내 다른 위치로 옮겨두거나, 항구에서 임시 하역 후 재적재해야 하는 경우가 발생할 수 있습니다. 

이러한 불필요한 재배치 작업은 많은 비용을 야기하므로 이를 최소화할 수 있도록 차량을 적재해야 합니다!

구체적인 문제 상황은 다음과 같습니다.

- 각 차량은 선박에 선적되어야 하는 출발지 항구(origin, O)와 차량이 하역될 도착지 항구(destination, D)가 주어집니다. 여러 개의 (O, D) pair가 있고, 각 pair에 대해 일정 수의 차량들이 배정되어 있습니다. 이를 차량 수송 수요(demand)라 합니다.
- 차량을 운반하는 선박의 항로(방문하는 항구 순서)는 주어져 있으며, 선박은 각 항구를 방문하면서 차량을 상하역합니다.
- 선박 안에는 한정된 공간이 있으며, 선박의 구조상 먼저 적재된 차량 하역 시 이동할 경로를 다른 차량이 막고 있을 수 있습니다. 이러한 경우, 다른 차량을 위치변경하거나 임시 하역 후 재적재하여야 합니다.
    - 재배치를 위해 임시 하역한 차량은 적재 시 기존과 다른 노드에 적재될 수 있습니다.
    - 모든 재배치는 비용이 발생합니다.
    - 각 항구에 임시로 하역 가능한 차량의 수는 제한이 없다고 가정합니다.
    - 재배치를 피하기 위해 일부 차량을 선적하지 않거나 하역하지 않을 수 없습니다. 즉, 주어진 차량 수송 수요는 모두 만족해야 합니다.
    


>여러분들은 **재배치를 포함하여 주어진 차량들을 상하역 하는데 발생하는 전체 비용의 합을 최소화**하는 최적화 알고리즘을 만들어야 합니다!


## 선박 구조

- 선박 내에는 차량을 적재할 수 있는 개별 공간(노드)이 있으며, 모든 차량은 이 공간 중 하나에 배치됩니다.
- 하나의 노드에는 한 대의 차량만 적재될 수 있습니다.
- 노드와 노드를 연결하는 간선으로 선박의 구조가 표현됩니다 (그림 1 예시).
- 모든 간선은 양방향(undirected) 입니다. 즉, 양쪽 방향으로 모두 이동 가능합니다.
- 노드는 차량이 배치될 수 있는 공간을 의미하며, 노드를 연결하는 간선은 차량이 이동할 수 있음을 나타냅니다. 이러한 간선들은 차량들의 상하역 또는 위치변경의 경로를 구성합니다.
- 주어진 노드들과 간선들로 선박의 내부 구조(deck graph)가 정의됩니다.

![그림 1. 선박 구조 예시](graph1.png)


- 아래와 같이 다양한 선박 구조가 제시될 예정입니다.
    
![그림 2. 다양한 선박 구조 예시](graph2.png)
    
    
> Deck graph의 구조에 제약은 없습니다. 즉, tree가 아닐수도 있고(위 그림에서 네번째 예제) 평면(planar graph)이 아닐수도 있습니다.


## 경로

- 출입구(노드 0)가 정해져 있어, 차량은 해당 위치로만 상하역 가능합니다.
    - 예를 들어, 그림 1에서 차량을 노드 5에 배치하려면 노드 0 → 노드 1 → 노드 2 → 노드 4 → 노드 5를 거쳐야 하며, 하역할 때는 반대로 노드 5 → 노드 4 → 노드 2 → 노드 1 → 노드 0을 거쳐야 합니다.
- **만약 경로 상에 다른 차량이 존재할 경우, 해당 차량을 다른 노드로 위치변경하거나, 임시로 하역한 뒤 재적재해야 합니다.**
- 예를 들어, 노드 5의 차량을 하역하여야 하는데 노드 2에 다른 차량이 존재하는 경우, 다음 두 가지 재배치 방법이 가능합니다.
    - 노드 2의 차량을 출입구 0을 통해 임시 하역 (노드 2 → 노드 1 → 노드 0) 후, 노드 5의 차량을 하역합니다. 이후에 임시 하역한 차량은 선박 내 비어있는 노드에 재적재합니다. (임시 하역 후 재적재)
    - 또는 노드 2의 차량을 노드 3으로 위치변경 (노드 2 → 노드 3) 후 노드 5의 차량을 하역합니다. (위치변경)
💡

> 어떤 경로가 모든 제약을 만족하면 **가능 경로(feasible route)** 라 합니다. 하나의 경로가 가능 경로가 되기 위해서는 다음의 제약을 모두 만족해야 합니다.
>
> - 경로는 노드들의 목록(list)으로 주어지며 모든 노드들은 deck graph에 존재해야 함
> - 경로 내의 연속된 두 개 노드로 정의되는 간선이 deck graph에 존재해야 함
> - 경로 상에 중복된 노드가 존재할 수 없음(simple route 제약)
> - 선적 경로는 항상 0번 노드가 첫 노드이며 차량을 이동하는 시점에 경로 상의 모든 노드(마지막 노드 포함)에 다른 차량이 없어야 함
> - 하역 경로는 항상 0번 노드가 마지막 노드이며 차량을 이동하는 시점에 첫번째 노드에는 하역할 차량이 존재하고 나머지 노드들에는 다른 차량이 없어야 함
> - 재배치를 위한 경로는 **위치변경** 또는 **임시 하역 후 재적재**가 가능함
>     - 위치변경 경로: 차량을 이동하는 시점에 첫번째 노드에는 항상 위치변경할 차량이 존재하고 나머지 노드에는 다른 차량이 없어야 함(마지막 노드가 위치변경한 노드가 됨)
>     - 임시 하역 후 재적재: **두 개의** **별도의 경로**가 생성되고 각각의 경로는 하역 경로 및 선적 경로의 제약을 만족해야 함

# 2. 문제 목표 – 총 비용 최소화

## **경로의 비용**

경로의 비용은 다음과 같이 계산됩니다.

> **이동 비용 = 고정비 + 이동 거리에 따른 변동비**

- 고정비는 한 경로에 한 번만 부과됩니다. 그리고 변동비는 경로의 길이에 비례합니다. 경로의 길이는 경로가 사용한 간선(edge)의 갯수로 정의됩니다.

> **주의!** 재배치를 위해 임시 하역 후 재적재하는 경우는 두 개의 경로가 생성되므로 고정비도 두 번 발생합니다.


**이동 비용 계산 예제**

- 노드에서 다른 노드로, 또는 노드에서 출입구로 이동할 때의 거리는 모두 1로 계산합니다.
- 고정비는 문제에서 주어집니다. 여기서는 10으로 가정합니다.
- 그림 1에서 선적한 차량을 각각 노드 3과 노드 2에 적재하면 출입구로부터 총 5(=3+2)만큼의 거리 이동이 발생합니다. 이후, 노드 2와 노드 3 순으로 적재된 차량을 하역할 경우에도 동일하게 5(=2+3)만큼의 거리 이동이 발생하므로, 전체 이동 거리는 10이 됩니다. 경로가 네 개(선적 2개+하역 2개)이므로 4번의 고정비가 발생하여 총 비용은 4*10 + 10 = 50 이 됩니다.
    - 만약 노드 3에 있는 차량을 노드 2의 차량보다 먼저 하역해야 한다면, 노드 2에 있는 차량을 재배치해야 합니다. 이때, 노드 2의 차량을 임시로 하역하는 데 2, 다시 적재하는 데 2가 추가로 발생하여 총 거리 4가 더해집니다. 두 개의 재배치 경로가 생성되고 총 거리가 4이므로 재배치 경로로 추가 발생하는 비용은 2*10 + 4 = 24 입니다.
💡

> 이 예제에서와 같이 선적과 하역 모두 경로들을 수행할 **순서**가 중요합니다. 경로의 수행 순서에 따라 재배치가 필요하지 않을수도 있고 반대로 재배치 비용이 증가할수도 있습니다! 
> 
> **경로의 수행 순서는 여러분들이 결정해야 합니다!** 
>
> 모든 경로들이 feasible하기만 하면 수행 순서에 제약은 없습니다. 즉, 선적, 하역, 재배치 경로들의 수행 순서에 제약은 없습니다. 임시 하역 후 재적재도 임시 하역 후 다른 경로들을 먼저 수행한 후에 재적재 가능합니다.



## 해(solution)

주어진 문제에 대해 여러분은 다음과 같은 해를 찾아야 합니다.

- 각 항구마다
    - 경로+이동할 차량 쌍(pair)들의 목록(route list)
        - 각 경로+이동할 차량 쌍은 각각 이동 경로와 이동할 차량이 어떤 수요의 차량인지를 나타냅니다.
- 경로+이동할 차량 쌍(pair)들의 목록의 순서대로 작업을 수행합니다. 각 경로의 수행이 끝나면 선박 내부의 상태가 변화하게 됩니다. 따라서 각 경로가 유효한지는 그 경로를 수행하는 그 시점의 선박 내부 상태에 의존합니다.
- **해에 속한 모든 경로가 유효** 하고 **주어진 수요를 모두 출발지(O)에서 목적지(D)까지 배송** 한다면 이를 유효해(feasible solution)라 합니다.

## 목적함수

목적함수는 해가 유효(feasible solution)한 경우에만 정의되며 목적함수의 값은 다음과 같이 계산됩니다.

- **(모든 경로의 비용의 합) - (총 비용 하한값(LB))**


> 총 비용 하한값은 다음과 같이 계산됩니다.
> 
> - $P$ : 항구의 집합
> - $F$ : 경로 고정비
> - $Load_p$ : 각 항구에서는 선적해야 하는 물량의 총합, i.e., 출발지가 $p$인 물량의 총합
> - $Unload_p$ : 각 항구에서는 하역해야 하는 물량의 총합, i.e., 목적지가 $p$인 물량의 총합
> - $N_m$ : Gate 노드를 제외한 노드들 중에 gate노드에서의 거리가 가장 가까운 $m$개의 노드 집합
> - $d_i$ : Gate 노드에서 노드 $i$ 까지의 최단거리
> 
> $$
> \text{LB} := \sum_{p \in P} \left[ F \times (Load_p + Unload_p) + \sum_{i \in N_{Load_p}} d_i + \sum_{i \in N_{Unload_p}} d_i  \right]
> $$
>
> LB는 deck graph의 gate 노드를 제외한 모든 노드들이 gate 노드와 직접 연결되는 간선(edge)을 추가하고 이 추가된 간선의 비용이 그 노드까지의 최단거리로 주어지는 상황에서의 최적해의 총 비용 값입니다. 즉, 다른 차량으로 인한 방해(blocking)를 무시했을 때 얻을 수 있는 최소 비용입니다.  
>
> ***Note: LB는 문제와 함께 주어지므로 별도로 계산할 필요가 없습니다!***
>
> 목적함수는 모든 경로의 비용의 합에서 LB를 뺀 값으로 정의됩니다. 즉, 목적함수를 최소화하기 위해서는
>
> 1. (최단거리 대비해서 증가하는) 선적/하역 경로길이를 줄이고
> 2. 재배치로 발생하는 비용을 줄여야
>
> 합니다. 


## 예시 문제

- 선박의 운항 경로
    - 항구 A→ 항구 B → 항구 C → 항구 D → 항구 E
- 차량 정보 및 적재 요구사항(demand)
    - 출발지 항구(origin) 및 목적지 항구(destination) 정보는 다음과 같습니다.
        
        
        | **수요** | 출발지 항구 (origin) | 목적지 항구 (destination) | 차량 대수      |
        | -------- | -------------------- | ------------------------- | -------------- |
        | 수요 0   | A                    | C                         | 2 (남색, 회색) |
        | 수요 1   | B                    | E                         | 1 (주황색)     |
        | 수요 2   | C                    | D                         | 1 (빨간색)     |
        | 수요 3   | B                    | D                         | 1 (초록색)     |
        | 수요 4   | D                    | E                         | 1 (분홍색)     |
- 선박의 적재 공간(deck graph)
    - 아래 그림 3과 같습니다.
    
![그림 3. 예시의 선박 구조](graph3.png)
        
💡

> 예시를 위해 각 경로의 종류를 다음과 같이 표현합니다. (여러분이 해를 제출할 때는 경로의 종류를 구분할 필요는 없습니다!)
>
> - […], 수요 X: 선적 경로
> - […], 수요 X: 하역 경로
> - […], 수요 X: 재배치 경로


- 해 예시
    - 항구 A: 총 비용 = (10 + 4) + (10 + 3) = 27
        - [노드 0, 노드 1, 노드 2, 노드 3, 노드 4], 수요 0
        - [노드 0, 노드 1, 노드 2, 노드 3], 수요 0
    - 항구 B: 총 비용 = (10 + 2) + (10 + 1) = 23
        - [노드 0, 노드 1, 노드 2], 수요 1
        - [노드 0,  노드 1], 수요 3
    - 항구 C: 총 비용 = (10 + 1) + (10 + 2) + (10 + 3) + (10 + 4) + (10 + 3) + (10 + 2) + (10 + 1) = 86
        - [노드 1, 노드 0], 수요 3
        - [노드 2, 노드 1, 노드 0], 수요 1
        - [노드 3, 노드 2, 노드 1, 노드 0], 수요 0
        - [노드 4, 노드 3, 노드 2, 노드 1, 노드 0], 수요 0
        - [노드 0, 노드 1, 노드 2, 노드 3], 수요 1
        - [노드 0, 노드 1, 노드 2], 수요 2
        - [노드 0, 노드 1], 수요 3
    - 항구 D: 총 비용 = (10 + 1) + (10 + 2) + (10 + 1) = 34
        - [노드 1, 노드 0], 수요 3
        - [노드 2, 노드 1, 노드 0], 수요 2
        - [노드 0, 노드 1], 수요 4
    - 항구 E: 총 비용 = (10 + 1) + ( 10 +3) = 24
        - [노드 1, 노드 0], 수요 4
        - [노드 3, 노드 2, 노드 1, 노드 0], 수요 1
- 이 해의 목적함수 값은
    - 모든 경로의 비용의 합 = 27 + 23 + 86 + 34 + 24 = 194
    - LB = (10 * (2 + 0) + (1+2) + (0)) + (10 * (2 + 0) + (1+2) + (0)) + (10 * (1 + 2) + (1) + (1+2)) + (10 * (1 + 2) + (1) + (1+2)) + (10 * (0 + 2) + (0) + (1+2)) = 23 + 23 + 34 + 34 + 23 = 137
    - 목적함수 값 = 194 - 137 = 57

![그림 4. 솔루션 예시](graph4.png)

💡

> 위 예제에서는 어쩔 수 없이 **하역 후 재적재를 통한 재배치 경로만 사용** 했습니다. Deck graph의 구조가 다른 경우에는 **위치변경 재배치 경로를 사용하면 더 비용을 줄일 가능성이 있습니다**. 어떤 재배치 방법을 사용할지는 여러분이 결정하셔야 합니다! 


# 3. 문제 데이터 정의

하나의 문제에는 다음과 같은 데이터가 제공됩니다.

- `N` : 노드 갯수(integer). `0`은 출입구(gate) 노드 `1,…,N-1` 은 차량 배차 가능 노드
- `E` : 간선(edge) 목록(list of edge pairs)
- `P` : 항구 갯수(integer). `0, 1, ..., P-1` 의 순서로 항구를 방문함(선박의 경로)
- `K` : 수송 수요 목록(list of ((O,D),quantity)).
- `F` : 경로 고정비
- `LB` : 총 비용 하한값
- `grid_graph` : 문제 시각화(visualization)를 위한 부가 정보. 문제를 푸는데 필수적이지 않음(optional data)

문제는 json 형태로 제공되며 아래와 같은 구조를 갖습니다.

```json
{
  "N": 49,
  "E": [
    [0, 1],
    [1, 2],
    [2, 3],
    [2, 4],
    
    ...
    
  ],
  "P": 10,
  "K": [
    [
      [0, 1], 4
    ],
    [
      [0, 2], 3
    ],
    [
      [0, 3], 2
    ],
    
		...
		
	],
  "F": 100,
  "LB": 13259,
  "grid_graph": ...

}
```

Notes:

- 간선 목록 `E` 의 경우 방향이 없고 임의의 한 방향만 목록에 주어집니다. 예를 들어 위 문제에서 `[0, 1]` 은 실제로 `0→1` 간선과 `1→0` 간선 두 개가 존재함을 의미합니다.
- 수요 목록 `K`는 수요의 출발지, 목적지, 차량의 수량을 나타냅니다. 예를 들어 `[0,1],4` 는 `0`번 항구에서 `1`번 항구로 수송해야하는 차량이 `4`대임을 나타냅니다.
    - 목록의 순서는 수요번호를 의미합니다. 위 예에서 `[0,1],4` 의 수요번호는 `0`이고 `[0,3],2` 의 수요번호는 2입니다.
    - 같은 출발항구-도착항구를 가지는 수요, 예를 들어 `[0,1],4` 수요의 4대의 차량은 **모두 동일**하다고 가정합니다. 따라서 알고리즘의 해를 반환할 때 이들 차량을 구분할 필요 없이 수요번호를 지정하면 충분합니다.

# 4. 알고리즘의 제출 및 평가

참가팀은 단계(예선, 본선, 결선)별로 주어지는 문제를 대상으로 알고리즘을 작성합니다(공개된 문제). 구현된 알고리즘 코드를 경연 시스템에 제출하면 숨겨진 문제를 대상으로 제출한 알고리즘을 실행해서 평가 합니다. 알고리즘 평가 서버 사양은 다음과 같습니다.

- AWS EC2 인스턴스(c5.4xlarge)
- 16 Core, 메모리 32 GB, Storage 32GB
- OS: Ubuntu 24.04 LTS

알고리즘은 실행시간제약(time limit)이 주어집니다. 실행시간제약은 문제마다 다를 수 있습니다. 각 단계 마다 참가팀들이 연습할 수 있는 문제를 공개하고 각각의 문제에 대한 실행시간제약도 같이 공개합니다. **알고리즘을 평가하는 숨겨진 문제들의 실행시간제약은 공개하지 않습니다.**

참가팀의 PC사양이 평가 서버의 사양과 다르기 때문에 참가팀의 알고리즘은 알고리즘 수행 중에 경과된 시간을 확인하여 제한시간을 넘지 말아야 합니다. 

또한 참가팀이 제출한 알고리즘은 다음과 같은 제약을 갖습니다.

- 알고리즘 수행 중에 외부 인터넷 접근 불가능
- 알고리즘이 실행되는 폴더보다 상위 폴더에 접근제한
- 최대 4개의 cpu core 사용 가능(~ CPU 사용률 400%)

위의 제약을 어기는 알고리즘은 실격처리될 수 있습니다. 

> **알고리즘 외부 인터넷 사용 여부와 cpu core 수는 평가 서버에서 알고리즘 실행 시 `firejail`과 `cpulimit` 를 통해 강제됨. 참가자의 알고리즘은 이 둘 프로그램과 충돌이 없어야 함**


참가팀은 하루에 2회 알고리즘을 제출할 수 있습니다. 한국 표준 시간으로 00:00:00 부터 11:59:59까지 1회 제출 가능하고 12:00:00부터 23:59:59까지 1회 제출 가능합니다. 즉, 제출 순간의 날짜 기준으로 정오(낮 12시)와 자정(밤 12시) 이전에 각각 1회씩 제출이 가능합니다.

> **알고리즘 제출은 하루에 정오 이전에 한번, 자정 이전에 한번 하루에 최대 2회만 가능!**


제출된 알고리즘은 평가 서버에서 숨겨진 문제를 대상으로 알고리즘을 실행해서 그 결과는 매 시각 취합됩니다. 취합하는 시각 기준으로, 모든 문제에 대해 결과가 나온 알고리즘들의 순위표(leaderboard)가 만들어지고 취합된 결과는 경연 홈페이지에 업데이트됩니다.

> **순위표는 한 시간마다 업데이트!**

참가팀이 제출한 알고리즘들 중에 가장 나중에 제출한 알고리즘 기준으로 모든 평가가 이루어집니다. 

> **평가 시각 기준으로 가장 최근에 제출한 알고리즘이 모든 평가의 기준!**

즉, 단계의 종료일 직전에는 가장 좋았던 알고리즘을 꼭 다시 제출하세요! 그렇지 않으면 마지막에 제출했던 알고리즘 기준으로 순위가 결정됩니다.

숨겨진 평가 문제는 공개하는 문제들과 비슷한 특성을 가지는 문제들로 이루어집니다. 단계별로 평가 문제의 갯수는 다르게 주어집니다. 예를 들어 5개 팀이 알고리즘을 제출하였고 3개의 숨겨진 평가 문제가 있을 때 숨겨진 문제를 푼 결과가 다음과 같다고 가정합니다. 

- `TEAM00`
    - `prob1: obj=60, feasible`
    - `prob2: obj=121, feasible`
    - `prob3: obj=82, feasible`
- `TEAM01`
    - `prob1: obj=104, infeasible`
    - `prob2: obj=223, feasible`
    - `prob3: obj=95, feasible`
- `TEAM02`
    - `prob1: obj=141, feasible`
    - `prob2: obj=125, feasible`
    - `prob3: obj=102, feasible`
- `TEAM03`
    - `prob1: obj=80, feasible`
    - `prob2: obj=136, feasible`
    - `prob3: obj=129, feasible`
- `TEAM04`
    - `prob1: obj=183, feasible`
    - `prob2: obj=210, feasible`
    - `prob3: obj=54, feasible`

위의 결과는 평가 시스템이 제출한 알고리즘을 숨겨진 문제에 대해 푼 결과입니다. 문제에 따라 infeasible 여부도 같이 판단됩니다. 그러면 문제 $p$에 대해 다음의 값을 계산할 수 있습니다.

$$
nb_p = |\{\text{문제 $p$에 대해 더 좋은 목적함수를 찾은 팀}\}|
$$

즉, $nb_p$는 문제 $p$에 대해 좋은 해를 찾은 알고리즘일수록 작은 값을 가지게 됩니다. 또한 이 때 찾은 해가 infeasible이거나 알고리즘의 실행 시 crash가 발생한 경우에는 가장 안 좋은 목적함수로 취급합니다. 

계산한 $nb_p$값으로 각 문제의 점수(point)는 다음과 같이 계산됩니다.

$$
p_p = \begin{cases} \max \{0, R-nb_p\} &\text{ if solution is feasible}\\ -1 &\text{otherwise} \end{cases}
$$

> **알고리즘의 해가 infeasible이거나 시간제한 초과, 수행 불가(crash)등의 경우에는 해당 문제에 대해 손해(penalty) 점수(-1)를 얻습니다!**

이 때 $R$은 평가하는 팀의 갯수입니다. 모든 문제에 대해 포인트를 계산하고 포인트의 총합 기준으로 순위가 결정됩니다. 아래 표는 위 예제에 대한 순위표를 보여줍니다.

```

  team  nb_prob1  p_prob1  nb_prob3  p_prob3  nb_prob2  p_prob2  total_score  **ranking**
TEAM00         0        5         1        4         0        5           14        1
TEAM02         2        3         3        2         1        4            9        2
TEAM05         3        2         0        5         3        2            9        2
TEAM03         1        4         4        1         2        3            8        4
TEAM01         5       -1         2        3         4        1            3        5
```

## 결선 평가 방법

💡

> **결선 기간에는 새로운 알고리즘을 제출하지 않고 본선에 마지막 제출한 알고리즘을 대상으로 숨겨진 문제를 푼 결과를 매일 업데이트할 예정입니다.**

결선에 진출한 참가팀을 대상으로 발표평가가 이루어지며, 심사위원의 평가 점수를 합산하여 발표평가 점수가 산정됩니다. 최종 순위는 결선 리더보드 득점과 발표평가 점수를 일정 비율로 합산하여 결정됩니다.

> **최종 순위는 결선 리더보드 득점과 발표평가 점수를 일정비율로 합산하여 결정.**

## 알고리즘 소스 코드 표절 검사

참가팀이 제출한 알고리즘은 참가팀의 충분한 기여점들을 포함해야 합니다. 예를 들어, 원래 같은 팀 멤버들이 거의 비슷한 알고리즘을 여러 팀 이름으로 제출하는 것은 허용되지 않습니다. **알고리즘 개발 방법** 에 자세히 나와 있는 대로 알고리즘 제출시에는 알고리즘의 소스도 같이 제출합니다. 제출한 소스는 추후 참가팀들 간에 소스의 표절여부를 확인할 때 사용될 수 있습니다. 알고리즘의 고유성 여부는 명확하게 판단하기 어려운게 사실입니다. 본 대회는 참가팀들이 상식적인 수준에서 명예로운 방식으로 대회에 참가하는것을 가정합니다. 만약에 이 가정에 어긋나는 행동을 한 참가팀은 운영 위원회의 결정에 따라 참여가 제한될 수 있습니다.