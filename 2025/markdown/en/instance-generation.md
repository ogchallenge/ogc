# Problem Generation Method

This section explains how Stage 3 problems are generated based on `stage3_prob_gen.ipynb`. Stage 1 and Stage 2 problems are generated in similar ways, with differences in parameter settings and graph structures. You can download and run the notebooks below to reproduce the generation process.

- [stage1_prob_gen.ipynb](prob_gen/stage1_prob_gen.ipynb)
- [stage2_prob_gen.ipynb](prob_gen/stage2_prob_gen.ipynb)
- [stage3_prob_gen.ipynb](prob_gen/stage3_prob_gen.ipynb)

---

## 1. Overall Generation Pipeline

The notebook workflow is as follows:

1. Create a `Prob(...)` object
2. Build a multilayer grid graph (`N`, `E`)
3. Randomly generate inter-port demands (`K`)
4. Remove unused ports (`remove_unused_ports`)
5. Compute lower bound (`LB`)
6. Save as JSON (`save_to_file`)
7. Split 14 generated instances into 10 evaluation + 4 practice instances

---

## 2. Core Class and Input Parameters

Instances are generated by the `Prob` class.

Main parameters:

- `P`: number of ports
- `H, W, L`: grid height/width/number of layers
- `F`: fixed handling cost (or baseline movement coefficient)
- `obstacle_ratio`: obstacle node ratio
- `total_allocation_ratio`: total demand allocation ratio
- `min_demands`: minimum demand generation unit-related parameter
- `rnd_seed`: random seed
- `inc`: layer-wise grid size increment
- `min_demand_interval`: minimum interval between origin and destination ports
- `asym_demand_prob`: asymmetric demand distribution flag
- `tri`, `diag`: triangular structure / diagonal-arc generation flags
- `ramp_one`, `rnd_ramp_pos`: number/location policy of inter-layer ramps

---

## 3. Graph Generation Logic (`_create_multilayer_grid_graph`)

### 3-1. Multilayer grid construction

- For each layer `l`, build a grid of size `H+inc*l` by `W+inc*l`.
- Node type starts as `hold` by default.
- Depending on `tri` and `diag`, horizontal/vertical/diagonal edges are added.

### 3-2. Inter-layer ramp connections

- Adjacent layers are connected via `ramp` edges.
- With `ramp_one=True`, typically a single ramp axis is used.
- With `rnd_ramp_pos=True`, ramp positions are randomized.

### 3-3. Gate/obstacle processing

- Node `(0,0,0)` is set as the `gate`.
- According to `obstacle_ratio`, some `hold` nodes become `obstacle` and their adjacent edges are removed.

### 3-4. Node ID assignment and reachability cleanup

- Assign node IDs in order of shortest distance from gate.
- Remove nodes unreachable from gate.

Graph information then appears in instances as:

- `N`: final node count
- `E`: edge list (node-ID pairs)

---

## 4. Demand Generation Logic (`_generate_random_demands`)

Demand `K` is randomly generated for port pairs `(origin, destination)`.

- Origins are sampled with higher probability toward earlier ports.
- Destination is chosen from ports at least `origin + min_demand_interval` away.
- Allocation checks ensure capacity (`max_capa`) is not exceeded.
- Repeat until reaching `total_allocation_ratio * max_capa * P`.

`K` is stored as a demand-quantity list per port pair.

---

## 5. Unused Port Removal (`remove_unused_ports`)

Ports never appearing as origin/destination are removed.

- Compute new port count `new_P`
- Re-index and compress into `new_K`

This reduces unnecessary problem size.

---

## 6. Lower Bound Calculation (`_get_LB`)

`LB` is a simple lower bound based on shortest distances from the gate (node 0).

- Aggregate total loading/unloading demand per port
- Accumulate in form `F * demand + sum of nearest-node distances`

This is used as a reference lower bound for evaluating algorithm performance.

---

## 7. Save Format (`save_to_file`)

The problem JSON includes:

- `N`: number of nodes
- `E`: edge list
- `P`: number of ports
- `K`: demand list
- `F`: cost coefficient
- `LB`: lower bound

With `with_graph=True`, original graph data is additionally included for visualization/debugging:

- `grid_graph.nodes`
- `grid_graph.edges`

---

## 8. Stage 3 Dataset Composition

The notebook generates `prob1.json` to `prob14.json`, then splits as follows:

- Fix random seed with `np.random.seed(2)`
- Randomly select 10 out of 14 → `stage3_problems` (evaluation)
- Remaining 4 → `stage3_exercise_problems` (practice)
- Rename each set sequentially from `prob1.json`

---

## 9. Summary

Core idea of `stage3_prob_gen.ipynb`:

- Randomly generate multilayer/obstacle/ramp graph structures,
- Allocate inter-port demand probabilistically under capacity constraints,
- Remove unused ports and compute lower bounds,
- Split into reproducible evaluation/practice sets using fixed random seeds,
- Save as distributable JSON instances.
